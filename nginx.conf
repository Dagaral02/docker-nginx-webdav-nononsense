daemon off;
user abc abc;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
  worker_connections  1024;
}

http {
  include    mime.types;
  dav_ext_lock_zone zone=foo:10m;
  
  send_timeout 3600;
  client_body_timeout 3600;
  keepalive_timeout 3600;
  lingering_timeout 3600;
  client_max_body_size 10G;
  
  create_full_put_path	on;
	min_delete_depth	0;
  
  server {
    server_name localhost;
    listen 80;
    
    set $destination $http_destination; 
    set $new_path "";
    set $webdav_root "/data";
    
    location ~ \.(_.*|DS_Store|Spotlight-V100|TemporaryItems|Trashes|hidden|localized)$ {
      access_log  off;
      error_log   off;
      
      if ($request_method = PUT) {
        return 403;
      }
      
      return 404;
    }

    location ~ \.metadata_never_index$ {
      return 200 "Don't index this drive, Finder!";
    }
    
    # With fixes for Windows from http://netlab.dhis.org/wiki/ru:software:nginx:webdav
    location / {
      auth_basic "Restricted";
      auth_basic_user_file htpasswd;
      
      dav_ext_lock zone=foo;
      dav_methods		PUT MKCOL;
      dav_ext_methods	OPTIONS LOCK UNLOCK;

      autoindex		on;
      autoindex_exact_size	on;
      autoindex_localtime	on;
      
      fancyindex on;
      fancyindex_exact_size off;
      fancyindex_localtime on;
      fancyindex_name_length 255;
      
      root			$webdav_root;
      
      error_page		599 = @propfind_handler;
      error_page		598 = @delete_handler;
      error_page		597 = @copy_move_handler;
      open_file_cache		off;
      
      if ($request_method = PROPFIND) {
        return 599;
      }
      
      if ($request_method = PROPPATCH) { # Unsupported, allways return OK.
        add_header	Content-Type 'text/xml';
        return		207 '<?xml version="1.0"?><a:multistatus xmlns:a="DAV:"><a:response><a:propstat><a:status>HTTP/1.1 200 OK</a:status></a:propstat></a:response></a:multistatus>';
      }
      
      if ($request_method = MKCOL) { # Microsoft specific handle: add trailing slash.
        rewrite ^(.*[^/])$ $1/ break;
      }
      
      if ($request_method = DELETE) {
        return 598;
      }
      
      if ($request_method = COPY) {
        return 597;
      }
      
      if ($request_method = MOVE) {
        return 597;
      }
      
      if ($request_method = OPTIONS) {
        add_header	Allow 'OPTIONS, GET, HEAD, POST, PUT, MKCOL, MOVE, COPY, DELETE, PROPFIND, PROPPATCH, LOCK, UNLOCK';
        add_header	DAV '1, 2';
        return 200;
      }
      
    }
    
    location @propfind_handler {
      internal;

      open_file_cache	off;
      
      if (!-e $webdav_root/$uri) { # Microsoft specific handle.
        return 404;
      }
      
      root			$webdav_root;
      dav_ext_methods		PROPFIND;
    }
    
    location @delete_handler {
      internal;
      open_file_cache	off;
      
      if ($destination ~ ^https?://(.*)$) {
        set $new_path $1;
        more_set_input_headers "Destination: http://$new_path";
      }
      
      if (-d $webdav_root/$uri) { # Microsoft specific handle: Add trailing slash to dirs.
        more_set_input_headers "Destination: http://$new_path/";
        rewrite ^(.*[^/])$ $1/ break;
      }
      
      root			$webdav_root;
      dav_methods		DELETE;
    }

    location @copy_move_handler {
      internal;
      open_file_cache	off;
      
      if ($destination ~ ^https?://(.*)$) {
        set $new_path $1;
        more_set_input_headers "Destination: http://$new_path";
      }
      
      if (-d $webdav_root/$uri) { # Microsoft specific handle: Add trailing slash to dirs.
        more_set_input_headers "Destination: http://$new_path/";
        rewrite ^(.*[^/])$ $1/ break;
      }
      
      root			$webdav_root;
      dav_methods		COPY MOVE;
    }
  }
}
